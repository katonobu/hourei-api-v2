# coding: utf-8

"""
    法令API Version 2

    ## はじめに > * 本APIは<a href=\"https://laws.e-gov.go.jp/apitop/\" target=\"_blank\">法令API（Version1）</a>を改良開発したHTTP APIです。<br> > * 仕様変更情報やサーバーメンテナンス情報につきましては、<a href=\"https://laws.e-gov.go.jp/\" target=\"_blank\">e-Gov法令検索</a>をご覧ください。<br> > * 取得可能な法令データの範囲は、<a href=\"https://laws.e-gov.go.jp/help/#:~:text=%E8%AA%AD%E3%81%BF%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84-,e%2DGov%E6%B3%95%E4%BB%A4%E6%A4%9C%E7%B4%A2%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6,-%E5%B9%B3%E6%88%9029%E5%B9%B4\" target=\"_blank\">e-Gov法令検索について</a>をご覧ください。 > * 法令構造や法令XMLの理解を深めたい方は、<a href=\"https://laws.e-gov.go.jp/docs/\"  target=\"_blank\">法令ドキュメンテーションα版</a>をご覧ください。<br> > * 本ページを視覚的にわかりやすく表現した<a href=\"https://laws.e-gov.go.jp/api/2/redoc/\"  target=\"_blank\">Redoc</a>も提供しておりますのでご覧ください。<br>   ## 注意事項 > <font color=\"red\">&nbsp;&nbsp;本APIが提供している機能のうち、以下は試行版となり仕様変更が発生する場合がありますのでご了承ください。</font><br> > <font color=\"red\">&nbsp;&nbsp;&nbsp;&nbsp;- 法令本文取得APIで返却されるJSON形式のデータ<br></font> > <font color=\"red\">&nbsp;&nbsp;&nbsp;&nbsp;- 法令本文ファイル取得APIで取得できるJSON形式のデータ<br></font> > <font color=\"red\">&nbsp;&nbsp;&nbsp;&nbsp;- キーワード検索APIで名称に`law_num`を含むパラメータ指定時のレスポンスデータ<br></font>   ## XML一括ダウンロードについて > &nbsp;&nbsp;本APIはe-Gov法令検索で公開されているデータを使用します。<br> > &nbsp;&nbsp;法令データをダウンロードする場合は、<a href=\"https://laws.e-gov.go.jp/bulkdownload/\" target=\"_blank\">XML一括ダウンロード</a>にアクセスするか、以下のURLを利用してダウンロードしてください。<br>   >> * ### すべての法令データ >>> <pre><code>     https://laws.e-gov.go.jp/bulkdownload?file_section=1&only_xml_flag=true   </code></pre>   >> * ### 法令分類データ >>> <pre><code>     https://laws.e-gov.go.jp/bulkdownload?file_section=2&category_cd={カテゴリーコード}&only_xml_flag=true   </code></pre>   >>> ※ {カテゴリーコード}はSchemasの<a href=\"#model-category_cd\">`category_cd`</a>を参照してください。<br> >>> ※ `category_cd`の2桁目、3桁目の0は除いてください。（例えば、憲法は`001`ではなく`1`を使用します）   >> * ### 最新の更新法令データ >>> <pre><code>     https://laws.e-gov.go.jp/bulkdownload?file_section=3&update_date={取得する法令データの日付}&only_xml_flag=true   </code></pre>     >>> ※ {取得する法令データの日付}は「YYYYMMDD」（YYYY:年、MM:月、DD:日）形式で指定してください。<br>   >>> 例： 2024年1月1日の場合は`20240101`<br>   >>> （更新法令データの取得範囲は過去３ヶ月です。）   ## 改正区分について > &nbsp;&nbsp;法令APIでは、法令一覧取得API、法令履歴一覧取得API、法令本文取得API、キーワード検索APIのレスポンス`revision_info`内の要素で以下のように判断できます。<br>   >> <table bgcolor=\"white\" border=\"1\">     <tr bgcolor=\"#DDFFFF\">         <th width=\"5%\">改正区分</th>         <th width=\"25%\">改正区分の見分け方</th>     </tr>     <tr>         <td>　新規制定 </td>         <td>　amendment_typeが「1」 かつ missionが「New」のもの</td>     </tr>     <tr>         <td>　一部改正 </td>         <td>　missionが「Partial」のもの</td>     </tr>     <tr>         <td>　被改正法 </td>         <td>　amendment_typeが「3」 かつ missionが「New」のもの</td>     </tr>     <tr>         <td>　廃止 </td>         <td>　amendment_typeが「8」 又は repeal_statusが「Repeal」「Expire」「LossOfEffectiveness」のもの</td>     </tr>   </table>   # noqa: E501

    The version of the OpenAPI document: 2.1.138
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from openapi_client import schemas  # noqa: F401


class RevisionInfo(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    法令の履歴に関する情報
    """


    class MetaOapg:
        
        class properties:
            law_revision_id = schemas.StrSchema
            
            
            class law_type(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            LawType,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'law_type':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            law_title = schemas.StrSchema
            law_title_kana = schemas.StrSchema
            abbrev = schemas.StrSchema
            category = schemas.StrSchema
            updated = schemas.DateTimeSchema
            amendment_promulgate_date = schemas.DateSchema
            amendment_enforcement_date = schemas.DateSchema
            amendment_enforcement_comment = schemas.StrSchema
            amendment_scheduled_enforcement_date = schemas.DateSchema
            amendment_law_id = schemas.StrSchema
            amendment_law_title = schemas.StrSchema
            amendment_law_title_kana = schemas.StrSchema
            amendment_law_num = schemas.StrSchema
            
            
            class amendment_type(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            AmendmentType,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'amendment_type':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class repeal_status(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            RepealStatus,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'repeal_status':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class repeal_date(
                schemas.DateBase,
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
                    format = 'date'
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[None, str, date, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'repeal_date':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                    )
            
            
            class remain_in_force(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'remain_in_force':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                    )
            
            
            class mission(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            Mission,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'mission':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class current_revision_status(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            CurrentRevisionStatus,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'current_revision_status':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            __annotations__ = {
                "law_revision_id": law_revision_id,
                "law_type": law_type,
                "law_title": law_title,
                "law_title_kana": law_title_kana,
                "abbrev": abbrev,
                "category": category,
                "updated": updated,
                "amendment_promulgate_date": amendment_promulgate_date,
                "amendment_enforcement_date": amendment_enforcement_date,
                "amendment_enforcement_comment": amendment_enforcement_comment,
                "amendment_scheduled_enforcement_date": amendment_scheduled_enforcement_date,
                "amendment_law_id": amendment_law_id,
                "amendment_law_title": amendment_law_title,
                "amendment_law_title_kana": amendment_law_title_kana,
                "amendment_law_num": amendment_law_num,
                "amendment_type": amendment_type,
                "repeal_status": repeal_status,
                "repeal_date": repeal_date,
                "remain_in_force": remain_in_force,
                "mission": mission,
                "current_revision_status": current_revision_status,
            }
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["law_revision_id"]) -> MetaOapg.properties.law_revision_id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["law_type"]) -> MetaOapg.properties.law_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["law_title"]) -> MetaOapg.properties.law_title: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["law_title_kana"]) -> MetaOapg.properties.law_title_kana: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["abbrev"]) -> MetaOapg.properties.abbrev: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["category"]) -> MetaOapg.properties.category: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["updated"]) -> MetaOapg.properties.updated: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_promulgate_date"]) -> MetaOapg.properties.amendment_promulgate_date: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_enforcement_date"]) -> MetaOapg.properties.amendment_enforcement_date: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_enforcement_comment"]) -> MetaOapg.properties.amendment_enforcement_comment: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_scheduled_enforcement_date"]) -> MetaOapg.properties.amendment_scheduled_enforcement_date: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_law_id"]) -> MetaOapg.properties.amendment_law_id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_law_title"]) -> MetaOapg.properties.amendment_law_title: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_law_title_kana"]) -> MetaOapg.properties.amendment_law_title_kana: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_law_num"]) -> MetaOapg.properties.amendment_law_num: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amendment_type"]) -> MetaOapg.properties.amendment_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["repeal_status"]) -> MetaOapg.properties.repeal_status: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["repeal_date"]) -> MetaOapg.properties.repeal_date: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["remain_in_force"]) -> MetaOapg.properties.remain_in_force: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["mission"]) -> MetaOapg.properties.mission: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["current_revision_status"]) -> MetaOapg.properties.current_revision_status: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["law_revision_id", "law_type", "law_title", "law_title_kana", "abbrev", "category", "updated", "amendment_promulgate_date", "amendment_enforcement_date", "amendment_enforcement_comment", "amendment_scheduled_enforcement_date", "amendment_law_id", "amendment_law_title", "amendment_law_title_kana", "amendment_law_num", "amendment_type", "repeal_status", "repeal_date", "remain_in_force", "mission", "current_revision_status", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["law_revision_id"]) -> typing.Union[MetaOapg.properties.law_revision_id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["law_type"]) -> typing.Union[MetaOapg.properties.law_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["law_title"]) -> typing.Union[MetaOapg.properties.law_title, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["law_title_kana"]) -> typing.Union[MetaOapg.properties.law_title_kana, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["abbrev"]) -> typing.Union[MetaOapg.properties.abbrev, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["category"]) -> typing.Union[MetaOapg.properties.category, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["updated"]) -> typing.Union[MetaOapg.properties.updated, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_promulgate_date"]) -> typing.Union[MetaOapg.properties.amendment_promulgate_date, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_enforcement_date"]) -> typing.Union[MetaOapg.properties.amendment_enforcement_date, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_enforcement_comment"]) -> typing.Union[MetaOapg.properties.amendment_enforcement_comment, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_scheduled_enforcement_date"]) -> typing.Union[MetaOapg.properties.amendment_scheduled_enforcement_date, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_law_id"]) -> typing.Union[MetaOapg.properties.amendment_law_id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_law_title"]) -> typing.Union[MetaOapg.properties.amendment_law_title, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_law_title_kana"]) -> typing.Union[MetaOapg.properties.amendment_law_title_kana, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_law_num"]) -> typing.Union[MetaOapg.properties.amendment_law_num, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amendment_type"]) -> typing.Union[MetaOapg.properties.amendment_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["repeal_status"]) -> typing.Union[MetaOapg.properties.repeal_status, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["repeal_date"]) -> typing.Union[MetaOapg.properties.repeal_date, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["remain_in_force"]) -> typing.Union[MetaOapg.properties.remain_in_force, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["mission"]) -> typing.Union[MetaOapg.properties.mission, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["current_revision_status"]) -> typing.Union[MetaOapg.properties.current_revision_status, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["law_revision_id", "law_type", "law_title", "law_title_kana", "abbrev", "category", "updated", "amendment_promulgate_date", "amendment_enforcement_date", "amendment_enforcement_comment", "amendment_scheduled_enforcement_date", "amendment_law_id", "amendment_law_title", "amendment_law_title_kana", "amendment_law_num", "amendment_type", "repeal_status", "repeal_date", "remain_in_force", "mission", "current_revision_status", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, ],
        law_revision_id: typing.Union[MetaOapg.properties.law_revision_id, str, schemas.Unset] = schemas.unset,
        law_type: typing.Union[MetaOapg.properties.law_type, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        law_title: typing.Union[MetaOapg.properties.law_title, str, schemas.Unset] = schemas.unset,
        law_title_kana: typing.Union[MetaOapg.properties.law_title_kana, str, schemas.Unset] = schemas.unset,
        abbrev: typing.Union[MetaOapg.properties.abbrev, str, schemas.Unset] = schemas.unset,
        category: typing.Union[MetaOapg.properties.category, str, schemas.Unset] = schemas.unset,
        updated: typing.Union[MetaOapg.properties.updated, str, datetime, schemas.Unset] = schemas.unset,
        amendment_promulgate_date: typing.Union[MetaOapg.properties.amendment_promulgate_date, str, date, schemas.Unset] = schemas.unset,
        amendment_enforcement_date: typing.Union[MetaOapg.properties.amendment_enforcement_date, str, date, schemas.Unset] = schemas.unset,
        amendment_enforcement_comment: typing.Union[MetaOapg.properties.amendment_enforcement_comment, str, schemas.Unset] = schemas.unset,
        amendment_scheduled_enforcement_date: typing.Union[MetaOapg.properties.amendment_scheduled_enforcement_date, str, date, schemas.Unset] = schemas.unset,
        amendment_law_id: typing.Union[MetaOapg.properties.amendment_law_id, str, schemas.Unset] = schemas.unset,
        amendment_law_title: typing.Union[MetaOapg.properties.amendment_law_title, str, schemas.Unset] = schemas.unset,
        amendment_law_title_kana: typing.Union[MetaOapg.properties.amendment_law_title_kana, str, schemas.Unset] = schemas.unset,
        amendment_law_num: typing.Union[MetaOapg.properties.amendment_law_num, str, schemas.Unset] = schemas.unset,
        amendment_type: typing.Union[MetaOapg.properties.amendment_type, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        repeal_status: typing.Union[MetaOapg.properties.repeal_status, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        repeal_date: typing.Union[MetaOapg.properties.repeal_date, None, str, date, schemas.Unset] = schemas.unset,
        remain_in_force: typing.Union[MetaOapg.properties.remain_in_force, None, bool, schemas.Unset] = schemas.unset,
        mission: typing.Union[MetaOapg.properties.mission, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        current_revision_status: typing.Union[MetaOapg.properties.current_revision_status, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'RevisionInfo':
        return super().__new__(
            cls,
            *_args,
            law_revision_id=law_revision_id,
            law_type=law_type,
            law_title=law_title,
            law_title_kana=law_title_kana,
            abbrev=abbrev,
            category=category,
            updated=updated,
            amendment_promulgate_date=amendment_promulgate_date,
            amendment_enforcement_date=amendment_enforcement_date,
            amendment_enforcement_comment=amendment_enforcement_comment,
            amendment_scheduled_enforcement_date=amendment_scheduled_enforcement_date,
            amendment_law_id=amendment_law_id,
            amendment_law_title=amendment_law_title,
            amendment_law_title_kana=amendment_law_title_kana,
            amendment_law_num=amendment_law_num,
            amendment_type=amendment_type,
            repeal_status=repeal_status,
            repeal_date=repeal_date,
            remain_in_force=remain_in_force,
            mission=mission,
            current_revision_status=current_revision_status,
            _configuration=_configuration,
            **kwargs,
        )

from openapi_client.model.amendment_type import AmendmentType
from openapi_client.model.current_revision_status import CurrentRevisionStatus
from openapi_client.model.law_type import LawType
from openapi_client.model.mission import Mission
from openapi_client.model.repeal_status import RepealStatus
